package IOD; # just to make PodWeaver happy

# VERSION

1;
#ABSTRACT: IOD file format specification

=head1 SPECIFICATION VERSION

0.9


=head1 STATUS

Specification is still rather in flux. Backwards compatibility is not guaranteed
between 0.9.x releases.

=head1 ABSTRACT

IOD (short for INI On Drugs) is a configuration file format that is
backwards-compatible with the popular INI format. It adds a few extensions to
make configuration more powerful but still lets the configuration parseable by a
regular INI parser (albeit the parse result might differ, sometimes
significantly so, but it can be exactly the same for simple cases). An
implementation can turn off some or all of these extensions to make the
configuration closer to a regular INI file.

IOD is meant to be a general configuration format for applications.


=head1 RATIONALE

A general configuration file format needs to be simple for computers as well as
users to read and write. Users mostly need to write configuration, while
computers need to read but increasingly nowadays also write to configuration
(for automation tasks). INI is chosen as the basis format for several reasons:
popularity, simplicity, and ease of round trip parsing. These features satisfy
the aforementioned requirement.

INI format is popular on Windows as well as Unix. This makes it easy for new
users to get started with the configuration.

INI format is simple and very straightforward. It is essentially assignments of
parameter names and values, with sections.

Round trip parsing means preserving everything in the file, including comments
and formatting (indentations, whitespaces). Most serialization format do not
have round trip parsers: after a read and write process, original formatting and
comments are lost. Round trip parsing means that if one loads an INI file,
modifies a parameter, and saves it again, everything that is not modified will
still be the same (including whitespaces and comments). If no parameters are
modified, the saved file will be identical with the original.

Round trip parsing is desirable in a configuration because oftentimes valuable
information is contained in the formatting/indentation (grouping of parameters)
as well as comments (user explaining why she sets a parameter to a certain
value, dates, other notes). Software modifying a configuration should not
destroy all these.


=head2 INI vs ...

Although B<YAML> looks nice and has many features, it lacks round trip parsers
and has complex rules that can trip beginners or non-programmers, e.g.
significant indentation, significant whitespace after colon in mapping, etc.

Although B<JSON> is popular, it lacks round trip parsers and some important
features (e.g. comments). (Note: The documentation for L<JSON> Perl module
mentions the phrase "round trip", but it uses the phrase to mean integrity of
values, not preserving comments/whitespaces.)

B<Apache-webserver-style> lacks round trip parsers.

B<XML> lacks round trip parsers and is not convenient for humans to read and
write.

=head2 Why not plain INI?

First, INI format is ill-defined. There is no single standard, thus various
implementations behave differently and there are various variants of the format.
This specification intends to describe the IOD format more precisely.

Second, INI lacks some features that I like/need, like: variable
substitution/expression, inclusion of other files, and merging between sections.
Most of these features make writing configuration less repetitive.

=head1 SPECIFICATION

A configuration is a text file containing a sequence of lines. Default encoding
is UTF-8. Each line is either a blank line, a comment line, a directive line, a
section line, or a parameter line. Parsing is done line-by-line and in a single
pass.

=head2 Blank line

A blank line is a line containing zero or more whitespaces only. It is ignored.

=head2 Comment line

A comment line begins with C<;> or C<#> as it's first nonblank character (note
that some INI parsers do not allow indented comment). The use of C<;> is
preferred.

=head2 Directive line

A directive line is a special unindented comment line, the comment starts with
zero or more whitespaces, an exclamation mark (C<!>), a directive name (a word
matching regular expression C</\w+/>, and zero or more arguments. Arguments are
words (or a quoted string) separated by whitespaces. An invalid directive will
cause parsing to fail.

Examples of valid directives:

 ;!include somefile.iod
 ;!include "c:/Configuration Files/somefile.ini"

This directive is invalid because of invalid name:

 ;!what-a-directive!

This directive is invalid because it is unknown:

 ;!foo

This directive is invalid because of unbalanced quotes:

 ;!include "somefile.ini

This directive is invalid because of missing required argument:

 ;!include

Below is the list of known directives (C<< <foo> >> signifies required
arguments, C<[foo]> signifies optional arguments):

=head3 !include <PATH>

Include another file, as if the content of the included file is the next lines
in the current file. An included file might contain another C<!include>
directive. If C<PATH> is not absolute, it is assumed to be relative to the
current file (or included file). A circular include will cause the parser to die
with an error. Example:

File C<dir1/a.ini>:

 [sectionA/sub1]
 a=1
 ;!include ../dir2/b.ini
 ;!include ../dir2/b3.ini

File C<dir2/b.ini>:

 b=2
 ;!include b2.ini

File C<dir2/b2.ini>:

 c = (2+1)
 ;!include b3.ini

File C<dir2/b3.ini>:

 c=4
 [sectionB]
 c=1

When C<dir1/a.ini> is parsed, the result will be (in JSON):

 {
   "sectionA": {
     "sub1": {
       "a": 1,
       "b": 2,
       "c": [3, 4]
     },
   },
   "sectionB": {
     "c": 1
   },
 }

=head3 !defaults <SECTION> [SECTION2] ...

Specify that from now on, when encountering a new section, fill it with values
from SECTION (and then SECTION2, and so on) unless the values are already
specified.

Example:

 [sect1]
 a=1
 b=2

 ;!defaults sect1

 [sect2]
 a=10

 [sect3]
 c=1

 [sect4]
 a=0
 b:=undef

Will result in:

 {
   "sect1": {"a": 1, "b": 2},
   "sect2": {"a": 10, "b": 2},
   "sect3": {"a": 1, "b": 2, "c": 1},
   "sect4": {"a": 0, "b": null}
 }

Another, more meaty example:

 [-defaults]
 quota=1000
 ftp=1
 shell=1
 mysql=0

 ;!defaults -defaults

 ; double quota for this user
 [user1]
 quota=2000

 ; disable ftp for this user
 [user2]
 ftp=0

 ; all admin users have unlimited quota
 [-admins]
 quota=-1

 ;!defaults -admins

 [admin1]

 ; this admin cannot use shell
 [admin2]
 shell=0

 ;no more defaults
 ;!defaults

Defaults to the same section is ignored.

=head3 !merge

Mode-merging using L<Data::ModeMerge>. Details to be specified later.

=head2 Section line

A section line introduces a section:

 [Section Name]
 ["quoted [] section name"]
 []
 [""]

Comment is allowed at the end. To write a section name with problematic
characters (like "\n", "\0", "]", etc.), use quotes.

To specify nested section, you indent the subsection line relative to section
line (minimum is 1 whitespace):

 [Outer]
   [Inner]
     [Further Inner]
       [a]
       val=1
       [b]
 [c]
 val=2

will result in:

 {Outer => {
     Inner => {
         "Further Inner" => {
             a => {
                 val => 1,
             },
             b => {
             },
         },
     },
  c => {
      val => 1,
  },
 },

Use of tab character is discouraged, but if exists as indentation it will be
counted as 1 whitespace. Parameter line needs to be indented at least as its
section:

 [Section]
   [Subsection]
   a=1
     b=2
   c=3
 d=4
  e=5

In the above example, a, b, and c belong to Subsection will d and e belong to
Section.

Non-contiguous sections are allowed, they will be assumed to be set/add
parameters, e.g.:

 [sect1]
 a=1

 [sect2]
 a=1

 [sect1]
 a=2
 b=3

will result in C<sect1> containing C<a> as [1, 2] and C<b> as 3. However, note:

 [sect1]
 a=1

 ;!defaults sect1
 [sect2]
 d=4

 [sect1]
 b=2

 [sect3]
 c=3

C<sect2> will contain {a=>1, d=>4} since at the point of parsing C<sect2>,
C<sect1> only contains {a=>1}. However, C<sect3> will contain {a=>1, b=>2, c=>3}
since at the point of parsing C<sect3>, C<sect1> already becomes {a=>1, b=>2}.

=head2 Parameter line

Parameter lines specify name value pairs:

 Parameter name = value
   Parameter2=value ; this is not a comment and part of value

Parameter name and value can be quoted:

 "Contains\nnewline" = "\0"

Whitespace before parameter name is allowed and can be used to enter/leave
subsection (see L</"Subsection line">). Whitespaces between the "=" character
are allowed and ignored. Trailing whitespace is allowed and ignored for quoted
values but significant for unquoted values.

 a=1<space>
 b="2"<space>

In the above example, value of C<a> is "1" followed by a space, while value of
C<b> is just "2".

Note that some INI parsers forbid some/all of these whitespaces.

Instead of "=" you can use ":=" to specify expression instead of literal value.
Expression is parsed by L<Language::Expr>. Using expression, you can specify a
null (undefined) value:

 param1 := undef

or alternative of writing arrays. Instead of:

 param=foo
 param=bar

you can write:

 param := ["foo", "bar"]

Using expression you can also specify an array with a single value (not possible
using "=").

 param:=["foo"]

You can also specify an empty array using expression:

 param:=[]

To escape ":" as part of parameter name, use quoting:

 "param:"="literal, not expression"

Normally a parameter line should occur below section line, so that parameter
belongs to the section. But a parameter line is also allowed before section
line, in which it will belong to section called C<DEFAULT> (configurable via the
parser's B<default_section> attribute).

=head2 Quoting

Quoting is done with the double-quote (L<">) character. Known escapes are \',
\", \\, \r (linefeed), \f (formfeed), \$ (literal $), \n (newline), \t (tab), \b
(backspace), \a (bell), \0, octal form ("\0377"), hex form ("\xff") and wide-hex
form (\x{263a}).

Quoting is allowed for section name in section line and for parameter name and
value in parameter line.

=head2 Includes

You can include another file using the !include directive:

 ;!include "/My Home/foo.ini"

See the documentation of the !include directive for more details.

=head2 Variables and calculations

You can use variables and calculations using the expressions.

 ; param is 1+2+$a, literal
 param=1+2+$a

 ; param is 5
 a=3
 b=4
 param := ($a**2 + $b**2) ** 0.5

 ; to refer to sections
 [Section1]
 lang="Perl"

 [Section2]
 param:="I love " + $CONFIG['Section1']['lang']

Note: since parsing is done in 1-pass, make sure that you define a parameter
first before using it in expressions.

=head2 Specifying defaults

To avoid repetition, you can specify defaults in a section and then use the
values in that section for others. See documentation on the !defaults directive
for more details.

=head2 Merging between sections

To be specified later.

=head2 Summary of extended features

Below is a summary of extended features provided by IOD over "standard" INI
format:

=over 4

=item * Round-trip parsing

=item * Quoting

=item * Indented section line, comments after section line

=item * Indented comment line

=item * Whitespaces before parameter name, between =, after parameter value

Some INI parsers do not allow whitespaces at all.

=item * # as comment character

Some strict INI parsers only recognize C<;> as the comment starter. If in doubt,
always use C<;>.

=item * Directives (e.g. include, defaults, merging)

Other INI parsers will see directive line as regular comment line.

=item * Expressions

Other INI parsers will see:

 param:=value

as { "param:" => "value" }.

=back

=head2 Unsupported features

Some INI implementation support other features, and listed below are those
unsupported by IOD, usually because the features are not popular:

=over 4

=item * Line continuation for multiline value

 param=line 1 \
 line 2\
 line 3

Supported by L<Config::IniFiles>. In IOD, use quoting:

 param="line 1 \nline 2\nline 3"

=item * Heredoc syntax for array

 param=<<EOT
 value1
 value2
 EOT

Supported by Config::IniFiles. In IOD, use multiple assignment or expression:

 param=value1
 param=value2

or:

 param:=["value1", "value2"]

=back


=head1 GUIDELINES FOR IMPLEMENTATIONS

Implementation can provide options to turn off some features. In general, to
make an IOD configuration file not context-dependent, a turned off feature
should cause parsing to fail to notify users that certain features are not
available. A turned off feature should not just silently makes parsing behave
differently. For example, if file inclusion is turned off, this line:

 !include somefile.ini

should make parsing fail instead of continuing (without including the file).

An exception is if implementation provides explicit option to ignore certain
features. For example, an implementation might provide an option to forbid
expressions, or turn off expression parsing and parse it as literal.

Below are guidelines on what parsing options an implementation can provide:

=over 4

=item * whether comment character C<#> is allowed

Some INI parsers (like PHP 5.3 or earlier) only recognize C<;> as the comment
character.

=item * whether indented comment line is allowed

Some INI parsers do not allow this.

=item * whether comment at the end of parameter line is allowed

Some INI parsers parse comments at the end of parameter line, some do not (they
assume it is part of parameter value). This option can avoid ambiguities by
forbidding such comments.

=item * whether comment at the end of section line is allowed

Some INI parsers parse comments at the end of parameter line, some do not. This
option can avoid ambiguities by forbidding such comments.

=item * whether indented section line is allowed

Some INI parsers do not allow indented section line.

=item * whether indented parameter line is allowed

Most parsers that I know allow indented parameter line, but may be some do not.

=item * whether expression is allowed

Expression is an IOD extension. If user wants her configuration to be more
INI-compatible, this option can be turned off.

=item * whether the !include directive is allowed

File inclusion is an IOD extension. If user wants her configuration to be more
INI-compatible, this option can be turned off.

=item * whether the !defaults and !merge directives are allowed

Merging between sections is an IOD extension. If user wants her configuration to
be more INI-compatible, this option can be turned off.

=back


=head1 FAQ

=head2 What are the downsides of IOD format?

=over 4

=item * Currently only has Perl parser (L<Config::IOD>)

INI parsers exist everywhere though, so some of the time you can fallback to
INI. It is also not terribly hard to write implementations in other languages.

=item * You need to learn another minilanguage for expressions

=back

=cut
